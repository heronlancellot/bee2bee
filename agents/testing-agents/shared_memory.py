"""
Shared Memory System for Agents
Enables agents to share and access collective knowledge
"""

import threading
from typing import Dict, List, Optional
from datetime import datetime, timedelta
from collections import defaultdict


class SharedMemory:
    """
    Centralized memory store that all agents can read from and write to
    """

    def __init__(self, max_items_per_type: int = 1000):
        self.lock = threading.Lock()
        self.max_items_per_type = max_items_per_type

        # Different types of memories
        self.knowledge_base: List[Dict] = []
        self.conversation_history: Dict[str, List[Dict]] = defaultdict(list)
        self.agent_insights: Dict[str, List[Dict]] = defaultdict(list)
        self.collaborative_sessions: Dict[str, Dict] = {}
        self.agent_metadata: Dict[str, Dict] = {}

    def store_knowledge(self, agent_id: str, topic: str, content: str,
                       tags: List[str] = None, source: str = None,
                       importance: float = 0.5) -> str:
        """
        Store knowledge in the shared knowledge base
        """
        with self.lock:
            knowledge_entry = {
                "id": f"knowledge_{len(self.knowledge_base)}_{datetime.now().timestamp()}",
                "agent_id": agent_id,
                "topic": topic,
                "content": content,
                "tags": tags or [],
                "source": source,
                "importance": importance,
                "timestamp": datetime.now().isoformat(),
                "access_count": 0
            }

            self.knowledge_base.append(knowledge_entry)

            # Trim if too large
            if len(self.knowledge_base) > self.max_items_per_type:
                # Remove oldest, least important items
                self.knowledge_base.sort(key=lambda x: (x["importance"], x["timestamp"]))
                self.knowledge_base = self.knowledge_base[-self.max_items_per_type:]

            return knowledge_entry["id"]

    def query_knowledge(self, query: str = None, tags: List[str] = None,
                       agent_id: str = None, limit: int = 10) -> List[Dict]:
        """
        Query the knowledge base
        """
        with self.lock:
            results = []

            for entry in self.knowledge_base:
                match = True

                # Filter by agent if specified
                if agent_id and entry["agent_id"] != agent_id:
                    match = False

                # Filter by tags if specified
                if tags and not any(tag in entry["tags"] for tag in tags):
                    match = False

                # Simple text search if query provided
                if query:
                    query_lower = query.lower()
                    if query_lower not in entry["topic"].lower() and \
                       query_lower not in entry["content"].lower():
                        match = False

                if match:
                    entry["access_count"] += 1
                    results.append(entry.copy())

            # Sort by importance and recency
            results.sort(key=lambda x: (x["importance"], x["timestamp"]), reverse=True)
            return results[:limit]

    def store_conversation_message(self, conversation_id: str, role: str,
                                  content: str, agent_id: str = None,
                                  metadata: Dict = None):
        """
        Store a message in conversation history
        """
        with self.lock:
            message = {
                "role": role,
                "content": content,
                "agent_id": agent_id,
                "timestamp": datetime.now().isoformat(),
                "metadata": metadata or {}
            }

            self.conversation_history[conversation_id].append(message)

            # Trim old messages (keep last 100 per conversation)
            if len(self.conversation_history[conversation_id]) > 100:
                self.conversation_history[conversation_id] = \
                    self.conversation_history[conversation_id][-100:]

    def get_conversation_history(self, conversation_id: str,
                                limit: int = None) -> List[Dict]:
        """
        Get conversation history
        """
        with self.lock:
            messages = self.conversation_history.get(conversation_id, [])
            if limit:
                return messages[-limit:]
            return messages.copy()

    def store_agent_insight(self, agent_id: str, insight_type: str,
                          content: str, confidence: float = 0.5,
                          related_to: str = None):
        """
        Store an insight generated by an agent
        """
        with self.lock:
            insight = {
                "id": f"insight_{agent_id}_{len(self.agent_insights[agent_id])}",
                "agent_id": agent_id,
                "type": insight_type,
                "content": content,
                "confidence": confidence,
                "related_to": related_to,
                "timestamp": datetime.now().isoformat(),
                "validated": False
            }

            self.agent_insights[agent_id].append(insight)

            # Trim if too many
            if len(self.agent_insights[agent_id]) > 100:
                self.agent_insights[agent_id] = self.agent_insights[agent_id][-100:]

            return insight["id"]

    def get_agent_insights(self, agent_id: str = None, insight_type: str = None,
                          min_confidence: float = 0.0, limit: int = 10) -> List[Dict]:
        """
        Retrieve agent insights
        """
        with self.lock:
            results = []

            # Determine which agents to check
            agents_to_check = [agent_id] if agent_id else self.agent_insights.keys()

            for aid in agents_to_check:
                for insight in self.agent_insights.get(aid, []):
                    if insight_type and insight["type"] != insight_type:
                        continue
                    if insight["confidence"] < min_confidence:
                        continue
                    results.append(insight.copy())

            # Sort by confidence and recency
            results.sort(key=lambda x: (x["confidence"], x["timestamp"]), reverse=True)
            return results[:limit]

    def create_collaborative_session(self, session_id: str, agents: List[str],
                                    goal: str, context: Dict = None):
        """
        Create a collaborative session between agents
        """
        with self.lock:
            self.collaborative_sessions[session_id] = {
                "id": session_id,
                "agents": agents,
                "goal": goal,
                "context": context or {},
                "started_at": datetime.now().isoformat(),
                "status": "active",
                "contributions": [],
                "shared_state": {}
            }

    def add_session_contribution(self, session_id: str, agent_id: str,
                                contribution: str, contribution_type: str = "insight"):
        """
        Add a contribution to a collaborative session
        """
        with self.lock:
            if session_id in self.collaborative_sessions:
                session = self.collaborative_sessions[session_id]
                session["contributions"].append({
                    "agent_id": agent_id,
                    "type": contribution_type,
                    "content": contribution,
                    "timestamp": datetime.now().isoformat()
                })

    def get_session(self, session_id: str) -> Optional[Dict]:
        """
        Get collaborative session details
        """
        with self.lock:
            return self.collaborative_sessions.get(session_id, {}).copy()

    def update_agent_metadata(self, agent_id: str, metadata: Dict):
        """
        Update or store agent metadata
        """
        with self.lock:
            if agent_id not in self.agent_metadata:
                self.agent_metadata[agent_id] = {}
            self.agent_metadata[agent_id].update(metadata)
            self.agent_metadata[agent_id]["last_updated"] = datetime.now().isoformat()

    def get_agent_metadata(self, agent_id: str) -> Dict:
        """
        Get agent metadata
        """
        with self.lock:
            return self.agent_metadata.get(agent_id, {}).copy()

    def get_all_agents_metadata(self) -> Dict[str, Dict]:
        """
        Get metadata for all agents
        """
        with self.lock:
            return {
                agent_id: metadata.copy()
                for agent_id, metadata in self.agent_metadata.items()
            }

    def get_relevant_context(self, query: str, agent_id: str = None,
                           max_knowledge: int = 5,
                           max_insights: int = 3) -> Dict:
        """
        Get relevant context for a query (knowledge + insights)
        """
        knowledge = self.query_knowledge(query=query, limit=max_knowledge)
        insights = self.get_agent_insights(
            agent_id=agent_id,
            min_confidence=0.5,
            limit=max_insights
        )

        return {
            "knowledge": knowledge,
            "insights": insights,
            "retrieved_at": datetime.now().isoformat()
        }

    def cleanup_old_data(self, days: int = 7):
        """
        Clean up data older than specified days
        """
        with self.lock:
            cutoff_date = datetime.now() - timedelta(days=days)

            # Clean old knowledge
            self.knowledge_base = [
                entry for entry in self.knowledge_base
                if datetime.fromisoformat(entry["timestamp"]) > cutoff_date
            ]

            # Clean old insights
            for agent_id in list(self.agent_insights.keys()):
                self.agent_insights[agent_id] = [
                    insight for insight in self.agent_insights[agent_id]
                    if datetime.fromisoformat(insight["timestamp"]) > cutoff_date
                ]

            # Clean completed sessions
            for session_id in list(self.collaborative_sessions.keys()):
                session = self.collaborative_sessions[session_id]
                if session["status"] == "completed":
                    session_date = datetime.fromisoformat(session["started_at"])
                    if session_date < cutoff_date:
                        del self.collaborative_sessions[session_id]

    def get_stats(self) -> Dict:
        """
        Get statistics about the shared memory
        """
        with self.lock:
            return {
                "knowledge_items": len(self.knowledge_base),
                "active_conversations": len(self.conversation_history),
                "total_messages": sum(
                    len(msgs) for msgs in self.conversation_history.values()
                ),
                "agents_tracked": len(self.agent_metadata),
                "total_insights": sum(
                    len(insights) for insights in self.agent_insights.values()
                ),
                "active_sessions": sum(
                    1 for s in self.collaborative_sessions.values()
                    if s["status"] == "active"
                )
            }


# Global shared memory instance
shared_memory = SharedMemory()
